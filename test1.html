<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Three.js Example 1</title>
    <script src="./js/jquery/jquery-1.11.3.min.js"></script>
    <script src="./js/three/three.js"></script>

    <script src="./js/map.js"></script>
    <script src="./js/loaders/MTLLoader.js"></script>
    <script src="./js/loaders/OBJLoader.js"></script>
    <script src="./js/loaders/DDSLoader.js"></script>
    <script src="./js/keyboard/keyboard.js"></script>
    <style type="text/css">
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        div#canvas-frame{
            border: none;
            cursor: pointer;
            background-color: #EEEEEE;
        }
        .btn {
            position: absolute;
            top: 200px;
            width: 200px;
            height: 100px;
        }
    </style>
</head>

<body onload="threeStart();">
<div id="canvas-frame"></div>
<button class="btn" onclick="toggleVisitMode()">Visit Mode</button>
</body>
<script>

    var renderer;
    var width, height;

    var minHeight = 10, maxHeight = 40;
    var collidableMeshList = [];

    /*Player related variables*/
    var playerNum = 0;
    var movFlag = [];
    var manPos = [];
    var movOfs = [];
    var manSize = new THREE.Vector3(2,8,2);
    var manObj = [];
    var modelPath = [ "models/antimage/antimage.json", "models/antimage/antimage.json"];
    var stepLen = 0.8;

    /*Camera related variables*/
    var PI = 3.1415926;
    var visitMode = false;
    var cameraAngelOfs = 0;
    var mouseX = 0, mouseY = 0;
    var midX = window.innerWidth / 2, midY = window.innerHeight / 2;
    var cameraDir;
    var cameraMov = 0;

    /*Light related variables*/
    var hemiLight;
    var sunLight;
    var moonLight;


    function initCanvas() {
        var $canvas = $("#canvas-frame");
        $canvas.width(document.body.clientWidth);
        $canvas.height(document.body.clientHeight);
    }

    function initThree() {
        width = document.getElementById('canvas-frame').clientWidth;
        height = document.getElementById('canvas-frame').clientHeight;
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(width, height );
        document.getElementById('canvas-frame').appendChild(renderer.domElement);
        renderer.setClearColor(0xFFFFFF, 1.0);
//            renderer.shadowMapEnabled = true;
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    }

    var camera;
    function initCamera() {
        camera = new THREE.PerspectiveCamera( 45 , width / height , 1 , 10000 );
        camera.position.x = 300;
        camera.position.y = 30;
        camera.position.z = 300;
        camera.up.x = 0;
        camera.up.y = 1;
        camera.up.z = 0;
        camera.lookAt( {x:0, y:0, z:0 } );
        cameraDir = new THREE.Vector3(-300, -30, -300);
    }

    function onDocumentMouseMove(event) {
        mouseX = -( event.clientX - window.innerWidth);
        mouseY = -( event.clientY - window.innerHeight );
//        console.log(mouseX,mouseY);
    }

    var scene;
    function initScene() {
        scene = new THREE.Scene();
    }

    var light, abt_light;
    function initLight() {
        light = new THREE.DirectionalLight(0xFFFFFF, 1.0);
        light.position.set( 40, 0, 50 );
        light.castShadow = true;
//        scene.add(light);

        abt_light = new THREE.AmbientLight(0x050505, 1.0);
        scene.add(abt_light);

        /*Hemisphere light*/
        hemiLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 0.8);
//        scene.add(hemiLight);

        /*Sunlight*/
        var sunRadius = 20;
        var sunIntensity = 100000;
        var sunGeometry = new THREE.SphereGeometry(sunRadius, 16, 16);
        sunLight = new THREE.PointLight(0xffee88, sunIntensity, 250, 2);
        var sunMat = new THREE.MeshStandardMaterial({
            emissive: 0xffffee,
            emissiveIntensity: sunLight.intensity / Math.pow(sunRadius,2),
            color: 0xFFFFFF
        });
        sunLight.add(new THREE.Mesh(sunGeometry, sunMat));
        sunLight.position.set(0, 200, 0);
        sunLight.castShadow = true;
        scene.add(sunLight);

        /*Moonlight*/
        var moonRadius = 10;
        var moonIntensity = 10000;
        var moonGeometry = new THREE.SphereGeometry(moonRadius, 16, 16);
        moonLight = new THREE.PointLight(0x191970, moonIntensity, 250, 2);
        var moonMat = new THREE.MeshStandardMaterial({
            emissive: 0x191970,
            emissiveIntensity: moonLight.intensity / Math.pow(moonRadius,2),
            color: 0x191970
        });
        moonLight.add(new THREE.Mesh(moonGeometry, moonMat));
        moonLight.position.set(0, 200, 0);
        moonLight.castShadow = true;
        scene.add(moonLight);
//
        /*Global options*/
        renderer.shadowMap.enabled = true;
        renderer.physicallyCorrectLights = true;
        renderer.gammaInput = true;
        renderer.gammaOutput = true;
    }

    var cube, sphere, plane;
    function initObject(){

        /*todo: this part can be modified as a rotating sun*/
//        var texture1 = new THREE.ImageUtils.loadTexture('./textures/planet1.jpg');
//        var sphere = new THREE.Mesh(
//                    new THREE.SphereGeometry(20, 20, 20),
//                    new THREE.MeshLambertMaterial({map: texture1})
//            );
//        scene.add(sphere);
//        sphere.position.set(0,0,0);


        /*Add an axis*/
        var axis = new THREE.AxisHelper(20);
        scene.add(axis);

        /*Add an geo-ground*/
        var mapArr = getMapArr(10);
        scene.addArr(mapArr);
        collidableMeshList = collidableMeshList.concat(mapArr);  // prepare for collision test


        /*Add an player*/
        initPlayer1(0);


        /*Add a skybox*/
        initSkyBox();

        /*Add floor*/
        initFloor();
    }

    function initFloor() {
        floorMat = new THREE.MeshStandardMaterial( {
            roughness: 0.8,
            color: 0xffffff,
            metalness: 0.2,
            bumpScale: 0.0005,
        });
        var textureLoader = new THREE.TextureLoader();
        textureLoader.load( "textures/hardwood2_diffuse.jpg", function( map ) {
            map.wrapS = THREE.RepeatWrapping;
            map.wrapT = THREE.RepeatWrapping;
            map.anisotropy = 4;
            map.repeat.set( 10, 24 );
            floorMat.map = map;
            floorMat.needsUpdate = true;
        } );
        textureLoader.load( "textures/hardwood2_bump.jpg", function( map ) {
            map.wrapS = THREE.RepeatWrapping;
            map.wrapT = THREE.RepeatWrapping;
            map.anisotropy = 4;
            map.repeat.set( 10, 24 );
            floorMat.bumpMap = map;
            floorMat.needsUpdate = true;
        } );
        textureLoader.load( "textures/hardwood2_roughness.jpg", function( map ) {
            map.wrapS = THREE.RepeatWrapping;
            map.wrapT = THREE.RepeatWrapping;
            map.anisotropy = 4;
            map.repeat.set( 10, 24 );
            floorMat.roughnessMap = map;
            floorMat.needsUpdate = true;
        } );
        var floorGeometry = new THREE.PlaneBufferGeometry( 200, 200, 20, 20 );
        var floorMesh = new THREE.Mesh( floorGeometry, floorMat );
        floorMesh.receiveShadow = true;
        floorMesh.rotation.x = -Math.PI / 2.0;
        scene.add( floorMesh );
    }

    function initPlayer() {
        playerNum++;
        manPos[0] = new  THREE.Vector3(0, 0, 0);
        movOfs[0] = new  THREE.Vector3(0, 0, 0);
        movFlag[0] = false;
        var onProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% downloaded' );
            }
        };

        var onError = function ( xhr ) { };

        THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );

        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath( 'models/male02/' );
        mtlLoader.load( 'male02_dds.mtl', function( materials ) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials( materials );
            objLoader.setPath( 'models/male02/' );
            objLoader.load( 'male02.obj', function ( object ) {

                object.position.set(manPos[0].x, manPos[0].y, manPos[0].z);
                object.scale.x = object.scale.y = object.scale.z = 0.05;

                manObj[0] = object;
                manObj[0].objSize = manSize;
                scene.add( object );

            }, onProgress, onError );

        });
    }

    function initPlayer1(x) {
        playerNum++;
        manPos[x] = new  THREE.Vector3(0, 0, 0);
        movOfs[x] = new  THREE.Vector3(0, 0, 0);
        movFlag[x] = false;
        var loader = new THREE.JSONLoader();
        loader.load(modelPath[x], function(geometry, materials) {
            var material = materials[0];
            material.morphTargets = true;
            material.color.setHex(0xaaaaFF);
            var faceMaterial = new THREE.MultiMaterial(materials);
            var mesh = new THREE.Mesh(geometry, faceMaterial);
            var s = 0.05;
            mesh.scale.set(s, s, s);
            mesh.position.set(0,10,0);
            mesh.rotation.set(1.5,0,0);
            mesh.matrixAutoUpdate = true;
            mesh.updateMatrix();
            scene.add(mesh);
            manObj[x] = mesh;
            manObj[x].objSize = manSize;
        });
    }

    function initSkyBox() {
        var imagePrefix = "images/dark-s_";
        var directions  = ["px", "nx", "py", "ny", "pz", "nz"];
        var imageSuffix = ".jpg";
        var skyGeometry = new THREE.CubeGeometry( 500, 500, 500 );

        var materialArray = [];
        for (var i = 0; i < 6; i++)
            materialArray.push( new THREE.MeshBasicMaterial({
                map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
                side: THREE.BackSide
            }));
        var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
        var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
        scene.add( skyBox );
    }

    function loop() {
        /*camera rotation*/
        if (visitMode) {
            var ofsAng = - (mouseX - midX) / midX * PI / 2 / 70;
            cameraDir.set(
                    cameraDir.x * Math.cos(ofsAng) - cameraDir.z * Math.sin(ofsAng),
                    (mouseY - midY) / midY *1.5 + cameraDir.y,
                    cameraDir.x * Math.sin(ofsAng) + cameraDir.z * Math.cos(ofsAng)
            );
            var destVec = camera.position.clone().add(cameraDir);
            camera.lookAt(destVec);
            var sclVec = new THREE.Vector3(5, 5, 5);
            var ofsVec = cameraDir.clone().normalize().divide(sclVec);
            if (cameraMov > 0) {
                camera.position.add(ofsVec);
            } else if (cameraMov < 0) {
                camera.position.sub(ofsVec);
            }
            cameraMov = 0;
        } else {
            camera.position.x = 60 * Math.cos( cameraAngelOfs );
            camera.position.y = 30;
            camera.position.z = 60 * Math.sin( cameraAngelOfs );
            camera.lookAt(scene.position);
        }
        /**/

        /*player movement*/
        for (var i=0; i<playerNum; i++) {
            if (!!manObj[i]) {
                if (movFlag[i]) {
                    manPos[i].add(movOfs[i]);
                    manObj[i].position.set(manPos[i].x, manPos[i].y, manPos[i].z);
                    if (checkCollision(manObj[i], collidableMeshList)) {
                        manPos[i].sub(movOfs[i]);
                        manObj[i].position.set(manPos[i].x, manPos[i].y, manPos[i].z);
                    }
                    movOfs[i].set(0, 0, 0);
                }
            }
            movFlag[i] = false;
        }
        /**/

        var timer = -0.0002 * Date.now();
        /*sunlight movement*/
        sunLight.position.y = 100 * Math.sin(timer);
        sunLight.position.z = 100 * Math.cos(timer);
        /**/
        
        /*moonlight movement*/
        moonLight.position.y = - 100 * Math.sin(timer);
        moonLight.position.z = - 100 * Math.cos(timer);
        /**/
        renderer.clear();
        renderer.render(scene, camera);
        window.requestAnimationFrame(loop);
    }

    function initKeyBoard() {
        keyboardJS.bind('w', function(e) {
            movOfs[0].x = stepLen;
            movFlag[0] = true;
        });
        keyboardJS.bind('s', function(e) {
            movOfs[0].x = -stepLen;
            movFlag[0] = true;
        });
        keyboardJS.bind('a', function(e) {
            movOfs[0].z = stepLen;
            movFlag[0] = true;
        });
        keyboardJS.bind('d', function(e) {
            movOfs[0].z = -stepLen;
            movFlag[0] = true;
        });
        keyboardJS.bind('+', function(e) {
            cameraAngelOfs += .01;
        });
        keyboardJS.bind('-', function(e) {
            cameraAngelOfs += .01;
        });
        keyboardJS.bind('q', function(e) {
            cameraMov = 1;
        });
        keyboardJS.bind('e', function(e) {
            cameraMov = -1;
        });
    }

    function toggleVisitMode() {
        visitMode = !visitMode;
    }

    function threeStart() {
        initCanvas();
        initThree();
        initCamera();
        initScene();
        initLight();
        initObject();
        initKeyBoard();
        loop();
        renderer.clear();
        renderer.render(scene, camera);
    }
</script>
</html>